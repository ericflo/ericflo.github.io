<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Eric Florenzano's Blog]]></title>
  <link href="http://eflorenzano.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://eflorenzano.com/"/>
  <updated>2012-04-18T17:34:47-07:00</updated>
  <id>http://eflorenzano.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Twitter's iOS5 Integration for Single Sign-On]]></title>
    <link href="http://eflorenzano.com/blog/2012/04/18/using-twitter-ios5-integration-single-sign-on/"/>
    <updated>2012-04-18T19:00:00-07:00</updated>
    <id>http://eflorenzano.com/blog/2012/04/18/using-twitter-ios5-integration-single-sign-on</id>
    <content type="html"><![CDATA[<p>Apple has included integration with Twitter in iOS5, which can be really handy
to allow your users to easily tweet or log in.  The only problem is that, as
far as documentation of this feature is concerned, you're largely on your own.
This blog post is an attempt to correct that, at least in the case of sign-on.</p>

<h1>Add the Twitter and Accounts libraries to your project</h1>

<p>Click on your project file, and then on your build target.  Make sure you're on
the "build phases" tab.  Under the "Link Binary With Libraries" section, click
the plus symbol to the bottom left, and search for <code>Accounts.framework</code> and
add it.  Then do the same for <code>Twitter.framework</code>.  This will link all of the
necessary libraries into your project so that we can use the Twitter
integration.</p>

<h1>Requesting access to a user's twitter account</h1>

<p>The first thing to do when you want to let a user sign-on with Twitter is to
create a long-lived (save it as an instance variable, for example) instance of
<code>ACAccountStore</code> and request access to the Twitter accounts contained within:</p>

<p>.. code-block:: obj-c</p>

<pre><code>ACAccountStore *store = [[ACAccountStore alloc] init]; // Long-lived
ACAccountType *twitterType = [store accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];
[store requestAccessToAccountsWithType:twitterType withCompletionHandler:^(BOOL granted, NSError *error) {
    if(granted) {
        // Access has been granted, now we can access the accounts
    }
    // Handle any error state here as you wish
}];
</code></pre>

<p>What do we do once we have access to the accounts?  Well, we get a list of 'em.
If they don't have any accounts, then we can show a dialog asking them to
connect one in the iOS settings app:</p>

<p>.. code-block:: obj-c</p>

<pre><code>// Remember that twitterType was instantiated above
NSArray *twitterAccounts = [store accountsWithType:twitterType];

// If there are no accounts, we need to pop up an alert
if(twitterAccounts != nil &amp;&amp; [twitterAccounts count] &gt; 0) {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"No Twitter Accounts"
                                                    message:@"There are no Twitter accounts configured. You can add or create a Twitter account in Settings."
                                                   delegate:nil
                                          cancelButtonTitle:@"OK"
                                          otherButtonTitles:nil];
    [alert show];
    [alert release];
} else {
    ACAccount *account = [twitterAccounts objectAtIndex:0];
    // Do something with their Twitter account
}
</code></pre>

<h1>Now what?</h1>

<p>Well, now you have an access token to read some information about the user from
their Twitter stream.  The vast majority of apps will just want to grab the
user's basic info to get things like a username, real name, and maybe their
location.  Here's how that would look:</p>

<p>.. code-block:: obj-c</p>

<pre><code>NSURL *url = [NSURL URLWithString:@"http://api.twitter.com/1/account/verify_credentials.json"];
TWRequest *req = [[TWRequest alloc] initWithURL:url
                                     parameters:nil
                                  requestMethod:TWRequestMethodGET];

// Important: attach the user's Twitter ACAccount object to the request
req.account = account;

[req performRequestWithHandler:^(NSData *responseData,
                                 NSHTTPURLResponse *urlResponse,
                                 NSError *error) {

    // If there was an error making the request, display a message to the user
    if(error != nil) {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Twitter Error"
                                                        message:@"There was an error talking to Twitter. Please try again later."
                                                       delegate:nil
                                              cancelButtonTitle:@"OK"
                                              otherButtonTitles:nil];
        [alert show];
        [alert release];
        return;
    }

    // Parse the JSON response
    NSError *jsonError = nil;
    id resp = [NSJSONSerialization JSONObjectWithData:responseData
                                                      options:0
                                                        error:&amp;jsonError];

    // If there was an error decoding the JSON, display a message to the user
    if(jsonError != nil) {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Twitter Error"
                                                        message:@"Twitter is not acting properly right now. Please try again later."
                                                       delegate:nil
                                              cancelButtonTitle:@"OK"
                                              otherButtonTitles:nil];
        [alert show];
        [alert release];
        return;
    }

    NSString *screenName = [resp objectForKey:@"screen_name"];
    NSString *fullName = [resp objectForKey:@"name"];
    NSString *location = [resp objectForKey:@"location"];

    // Make sure to perform our operation back on the main thread
    dispatch_async(dispatch_get_main_queue(), ^{
        // Do something with the fetched data
    });
}];
</code></pre>

<p>Most of the code here is actually error handling code.  The meat of what we're
doing is simply fetching the user's credentials from Twitter, parsing the JSON,
and doing something with it. (What exactly you want to do with the username and
name data is left as an excercise for the reader.)</p>

<h1>That's it?</h1>

<p>Yep, that's it.  You should be able to implement Twitter sign-on for your app
with the simple code I've shown here.  The only bummer is the case when the
user doesn't have a Twitter account registered.  We're <code>not allowed</code>_ to help
the user out by sending them to the Settings app.  All we can do is tell users
to go there and hope they can figure it out.</p>

<p>Any other tips or tricks you have for implementing sign-on with Twitter on iOS?
Be sure to <code>tweet me</code>_ about it!</p>

<p>P.S. If you're building mobile apps, my startup <code>clutch.io</code>_ can help you build
and iterate faster on them. Check us out :)</p>

<p>.. <em><code>not allowed</code>: http://stackoverflow.com/questions/10055853/opening-ios-settings-preferences
.. </em><code>tweet me</code>: http://twitter.com/ericflo
.. _<code>clutch.io</code>: https://clutch.io/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reducing Code Nesting]]></title>
    <link href="http://eflorenzano.com/blog/2012/01/01/reducing-code-nesting/"/>
    <updated>2012-01-01T18:00:00-08:00</updated>
    <id>http://eflorenzano.com/blog/2012/01/01/reducing-code-nesting</id>
    <content type="html"><![CDATA[<p>"This guy's code sucks!"  It's something we've all said or thought when we run
into code we don't like.  Sometimes it's because it's buggy, sometimes it's
because it conforms to a style we don't like, and sometimes it's because it
just feels wrong.  Recently I found myself thinking this, and automatically
jumping to the conclusion that the developer who wrote it was a novice.  The
code had a distinct property that I dislike: lots of nesting.  But the more I
think about it, the more I realized that it's not really something I've heard
discussed much.</p>

<p>So let's talk about it.  I'm going to first talk about what I mean by nesting,
why I think it's a bad quality, and then I'm going to go over some tricks I've
learned over the years to reduce it.</p>

<h2>What do I mean by code nesting, and why is it bad?</h2>

<p>It's easier to demonstrate rather than talk about it.  This is what I mean by
deep code nesting, with my apologies for the contrived example:</p>

<p>.. code-block:: python</p>

<pre><code>def get_cached_user(user_id=None, username=None):
    """
    Returns a cached user object either by their user_id or by their username.
    """
    user = cache.get_user_by_id(user_id)
    if not user:
        user = cache.get_user_by_username(username)
        if not user:
            user = db.get_user_by_id(user_id)
            if not user:
                user = db.get_user_by_username(username)
                if not user:
                    raise ValueError('User not found')
            cache.set_user(user, id=user.id, username=user.username)
    return user
</code></pre>

<p>You can see in this Python code just by looking at the indentation level that
there's lots of nesting.  Before we can determine that the user was not found,
we must pass through four conditionals, and each conditional is nested within
the previous conditional.</p>

<p>I argue that this is bad code.  Every added level of nesting is another piece
of context that your brain has to keep track of.  Each nested block is one you
have to line up by eye to see what conditional it lines up with (even if your
editor helps at this with visuals, it doesn't remove the issue entirely.)  And
this is just a straightforward example where we just return the user at the
end, let's take a look at an example that does something more complicated:</p>

<p>.. code-block:: python</p>

<pre><code>def get_media_details(media):
    """
    Returns a dictionary of extra data about the given media object.
    """
    data = {}
    if media.is_video:
        data['kind'] = 'video'
        if media.is_youtube:
            data['url'] = 'http://youtube.com/'
        if media.is_vimeo:
            data['vimeo'] = True
            if media.vimeo_version == 2:
                data['url'] = 'http://vimeo.com/v2/'
        if 'url' in data:
            data['secure_url'] = data['url'].replace('http:', 'https:')
    elif media.is_audio:
        data['kind'] = 'audio'
    elif media.is_text:
        data['kind'] = 'text'
    if 'kind' in data:
        data['kind_verbose'] = {
            'video': 'Video Stream',
            'audio': 'Audio File',
            'text': 'Text Content',
        }[data['kind']]
    return data
</code></pre>

<p>It was unbelievably hard for me to even write that last example.  It's
obviously contrived and such, but the point is that it's so difficult to
even understand what it's doing.  Unlike the previous example, this doesn't
simply nest and then return; it nests and then un-nests, and then nests again,
and then finally returns.</p>

<h2>How to Avoid Nesting</h2>

<p>The best way that I've discovered to avoid nesting is to return early.  Caching
is the perfect example of this.  Instead of testing for a cache failure and
fetching from the database inside the conditional, check for cache success and
return that early.</p>

<p>So this code:</p>

<p>.. code-block:: python</p>

<pre><code>def get_cached_user(user_id):
    user = cache.get_user_by_id(user_id)
    # The main logic all happens in this nested block
    if not user:
        user = db.get_user_by_id(user_id)
        cache.set_user_for_id(user_id, user)
    return user
</code></pre>

<p>Becomes this:</p>

<p>.. code-block:: python</p>

<pre><code>def get_cached_user(user_id):
    user = cache.get_user_by_id(user_id)
    if user:
        return user
    # The main logic happens outside of the nested block
    user = db.get_user_by_id(user_id)
    cache.set_user_for_id(user_id, user)
    return user
</code></pre>

<p>In the simple case, it doesn't seem to improve much, but what happens if we
apply this technique to our first example?  It's dramatically improved:</p>

<p>.. code-block:: python</p>

<pre><code>def get_cached_user(user_id, username):
    # First check the cache by id
    user = cache.get_user_by_id(user_id)
    if user:
        return user

    # Now check the cache by username
    user = cache.get_user_by_username(username)
    if user:
        return user

    # Both caches failed, so try hitting the db for the id
    user = db.get_user_by_id(user_id)
    if user:
        cache.set_user(user, id=user.id, username=user.username)
        return user

    # Looks like that didn't exist, try the username
    user = db.get_user_by_username(username)
    if not user:
        raise ValueError('User not found')

    # Cache our final user value for future use
    cache.set_user(user, id=user.id, username=user.username)
    return user
</code></pre>

<p>Not only does it make it easier to read top-to-bottom, and force us to keep
track of way less context, and make our code editors do less line wrapping,
but it also makes it easier to separate the blocks of code and more easily
comment them.</p>

<p>So what other techniques can we use?  It starts to depend more on the
situation.  Are you nesting because you're writing a bunch of callbacks?  If
so, you can usually restructure your code to use named functions instead of
anonymous functions.  Here's how that would might look before refactoring:</p>

<p>.. code-block:: javascript</p>

<pre><code>function getCachedUser(userId, callback) {
    cache.getUser(userId, function(user) {
        if(user) {
            return callback(user);
        }
        db.getUser(userId, function(user) {
            cache.setUser(userId, user, function() {
                callback(user);
            });
        });
    });
}
</code></pre>

<p>Note that in this example we even applied the technique of returning early in
the first callback function, but as you can see there's still a bunch of
nesting going on.  Now if we switch to using named functions?</p>

<p>.. code-block:: javascript</p>

<pre><code>function curry(fn) {
    var slice = Array.prototype.slice;
    var args = slice.apply(arguments, [1]);
    return function () {
        return fn.apply(null, args.concat(slice.apply(arguments)));
    };
}

function final(callback, user) {
    callback(user);
}

function dbResult(callback, userId, user) {
    cache.setUser(userId, user, curry(final, callback, user));
}

function cacheResult(callback, userId, user) {
    if(user) {
        return callback(user);
    }
    db.getUser(userId, curry(dbResult, callback, userId));
}

function getCachedUser(userId, callback) {
    cache.getUser(userId, curry(cacheResult, callback, userId));
}
</code></pre>

<p>This is a lot better in terms of nesting.  Unfortunately we had to write a
helper function called curry, but that only has to be written once and can be
re-used for all code written in this style.  Also unfortunately I still find
this kind of code difficult to follow, which is why I avoid writing much
callback-style code.  However, at least you can reduce the nesting.  In all
honesty, there are probably better ways of reducing nesting that I'm not aware
of.  If you can rewrite the <code>getCachedUser</code> function in JS in a better way,
please blog it!</p>

<p>Another way to reduce nesting is to assign an intermediate variable.  Here's
an example in Erlang of some file function that nests a case statement within
another case statement.</p>

<p>.. code-block:: erlang</p>

<pre><code>do_some_file_thing(File) -&gt;
    case file:open(File, [raw, binary, read]) of
        {ok, Fd} -&gt;
            Start = now(),
            case process_file_data(Fd) of
                {ok, Processed} -&gt;
                    {ok, Start, now(), Processed};
                Error -&gt;
                    Error
            end;
        Error -&gt;
            Error
    end.
</code></pre>

<p>We can assign to an intermediate "Resp" variable, and bring that second case
statement out into the function's main code block, like so:</p>

<p>.. code-block:: erlang</p>

<pre><code>do_some_file_thing(File) -&gt;
    Resp = case file:open(File, [raw, binary, read]) of
        {ok, Fd} -&gt;
            {timestamp, now(), process_file_data(Fd)};
        Error -&gt;
            Error
    end,
    case Resp of
        {timestamp, Start, {ok, Processed}} -&gt;
            {ok, Start, now(), Processed};
        {timestamp, Start, Error} -&gt;
            Error;
        Error -&gt;
            Error
    end.
</code></pre>

<h2>What does this all mean?</h2>

<p>At the end of the day, this isn't going to make or break you as a programmer.
In fact, nothing I've mentioned even changes the code's logic, but simply its
implementation.  It's simply something to think about as you code, as you read
other people's code.  Hopefully you agree with me that less nesting is an
admirable goal, and you find more and more ways to achieve it.</p>

<p>Discuss this post <code>on Hacker News</code>_.</p>

<p>.. _<code>on Hacker News</code>: http://news.ycombinator.com/item?id=3414526</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why node.js disappoints me]]></title>
    <link href="http://eflorenzano.com/blog/2010/09/27/why-node-disappoints-me/"/>
    <updated>2010-09-27T01:23:47-07:00</updated>
    <id>http://eflorenzano.com/blog/2010/09/27/why-node-disappoints-me</id>
    <content type="html"><![CDATA[<p>
<code>Node.js</code>_ is currently at the center of a huge cyclone of hype.  At this point it's clear that Node is going to be a major player in the next few years of web development.  It's no wonder, either!  It represents a fresh start, one with no legacy synchronous baggage in our increasingly asynchronous, increasingly real-time web. And it's accessible to anyone who's written JavaScript (read: all web developers.)</p>

<p>Oh, and those benchmarks!  Compared trivially to the currently popular web technologies, it seems an obvious leap forward.</p>

<p>Yet one of Node's advantages that you'll hear repeated again and again by its proponents is that you can now code in One Language, and you won't have to deal with the cognitive load of context switching between different languages.  Especially as ORMs and NoSQL continue to rise in popularity, there's no need to even deal with SQL. At the end of the day you're writing JavaScript, HTML, and CSS, and that's it.</p>

<p>Seeing this happen with all of these pieces falling into place--a fresh start with a unified language--I started to get excited.  This would change the way we thought about our web code.  The frontend is the backend is the query language is the storage layer is JavaScript!  It's a revolution.</p>

<p>And then I saw what people did with this opportunity.  They effectively ported Sinatra/Django/Rails to JavaScript--and did it in such a way that it would only run on the server, with a specific feature set of JavaScript that only Node can reasonably understand.</p>

<p>Not exactly the revolution I was hoping for.</p>

<p>Instead of coding in one language, we're actually coding in two. One is the subset JavaScript that can be run in all browsers, and another is the set of JavaScript that can be run by Node.  Knowing the difference between the two languages and context switching between them is simply a required skill.</p>

<p>You know what would be awesome? If we wrote our libraries so that they could run either on the server or on the client, and they did so in a transparent way.  Maybe it would help to give a concrete example of how this could be awesome.  Let's talk about HTML templating.</p>

<p>Imagine a framework where the first page-load was always rendered server-side, meaning the client gets a single fully-rendered page.  Then for desktop browsers, browsing around the site just made calls to API endpoints returning JSON or XML, and the client rendered the templates for the changed portions of the page.  For mobile browsers with less power or for search engines, the rendering would always be done on the server.  Imagine that the templating library could record some key metrics to determine how long things were taking to render, and dynamically switch between rendering on the server and client based on server load or client speed.</p>

<p>Imagine a case where a back-end service fails temporarily.  In this case the rendering of that particular component could be deferred, the browser could be told to poll a resource.  When the back-end service is recovered, it could send the data for the client to render on its own.</p>

<p>How awesome would that be?</p>

<p>It's not just HTML templating, either.  This same principle could be applied to any number of things: URL routing, form validation, hell even most application logic could be done using this style.</p>

<p>But it's going to take discipline.  Instead of reaching for those fancy V8 features, code will need to be written in a strict subset of the JavaScript that's available.  Maybe Node could detect incompatible code and throw warnings, that would be cool.</p>

<p>I just really hope that someday we stop re-inventing the same exact wheel, and instead build something substantially different and better.</p>

<p>.. _<code>Node.js</code>: http://nodejs.org/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Thoughts on NoSQL]]></title>
    <link href="http://eflorenzano.com/blog/2009/07/21/my-thoughts-nosql/"/>
    <updated>2009-07-21T06:44:17-07:00</updated>
    <id>http://eflorenzano.com/blog/2009/07/21/my-thoughts-nosql</id>
    <content type="html"><![CDATA[<p>
Over the past few years, relational databases have fallen out of favor for a
number of influential people in our industry.  I'd like to weigh in on that,
but before doing so, I'd like to give my executive summary of the events leading up to
this movement:</p>

<p>In the late nineties and early thousands, websites were mostly read-only--a
publisher would create some content and users would consume that content.
The data access patterns for these types of applications became very
well-understood, and as a result many tools were created and much research and
development was done to further develop these technologies.</p>

<p>As the web has grown more social, however, more and more it's the people
themselves who have become the publishers.  And with that fundamental shift
away from read-heavy architectures to read/write and write-heavy
architectures, a lot of the way that we think about storing and retrieving
data needed to change.</p>

<p>Most people have done this by relying less on the features provided by
traditional relational databases and engineering more database logic in their
application code.  Essentially, they stop using relational databases the way
they were intended to be used, and they instead use them as dumb data stores.</p>

<p>Other people have engineered new database systems from the ground up, each
with a different set of tradeoffs and differences from their relational
database brethren.  It's these new databases that have some in our industry
excited, and it's these databases that I'm going to focus on primarily in this
post.</p>

<p>(By the way, there's a whole lot more theory behind the movement away from
SQL.  Primarily of interest is the CAP theorem and the Dynamo paper.  Both of
these illustrate the necessary tradeoffs of between different approaches to
designing databases.)</p>

<h2>Let's get this out of the way</h2>

<p>I love SQL.  More than even that, I love my precious ORM and being able to
query for whatever information I want whenever I want it.  For the vast
majority of sites out there (we're talking 99.9% of the sites out there,
folks) it suits their needs very well, providing a good balance of ease of use
and performance.</p>

<p>There's no reason for them to switch away from SQL, and there's no way they
will.  If there's one thing I <em>don't</em> like about this whole NoSQL movement,
it's the presumption that everyone who's interested in alternative databases
hates the status quo.  That's simply not true.</p>

<p>But we're not talking about most sites out there, we're not talking about the
status quo, we're talking about the few applications that need something
totally different.</p>

<h2>Tokyo Cabinet / Tokyo Tyrant</h2>

<p>Tokyo Cabinet (and its network interface, Tokyo Tyrant) is the logical
successor to Berkeley DB--a blazing fast, open-source, embeddable key-value
store that does just about what you would expect from its description.  It
supports 3 modes of operation: hashtable mode, b-tree mode, and table mode.</p>

<p>(Table mode still pretty much sucks, and I'm not convinced it's a good idea
for the project since it's added bloat and other systems like RDBMs are
probably better for storing tabular data, so I'm going to skip it.)</p>

<p>Essentially, the API into Tokyo Cabinet is that of a gigantic associative
array.  You give it a key and a value, and then later, given a key, it will
give you back the value you put in.  Its largest assets are that it's fast and
straightforward.</p>

<p>If your problem is such that you have a small to medium-sized amount of data,
which needs to be updated rapidly, and can be easily modeled in
terms of keys and values (almost all scenarios can be rewritten in terms of
keys and values, but some problems are easier to convert than others), then
Tokyo Cabinet and Tokyo Tyrant are the way to go.</p>

<h2>CouchDB</h2>

<p>CouchDB is similar to Tokyo Cabinet in that it essentially maps keys to data,
but CouchDB's philosophy is completely different. Instead of arbitrary data,
its data has structure--it's a JSON object.  Instead of only being able to
query by keys, you can upload functions that index your data for you and then
you can call those functions.  All of this is done over a very simple REST
interface.</p>

<p>But none of this really matters.  None of these really set CouchDB apart,
because you could just encode JSON data and store it in Tokyo Cabinet, you can
maintain your own indexes of data fairly easily, and you can build a simple
REST API in a matter of days, if not hours.</p>

<p>What really sets CouchDB apart from the pack is it's innovative replication
strategy.  It was written in such a way that nodes which are disconnected for
long periods of time can reconnect, sync with each other, and reconcile their
differences in a way that no other database (since Lotus Notes?) could do.</p>

<p>It's functionality that allows for interesting and new distributed types of
applications and data that I think could possibly change the way we take our
applications offline.  I imagine that some day every computer will come with
CouchDB pre-installed and it'll be a data store that we use without even
knowing that we're using it.</p>

<p>However, I wouldn't choose it for a super high scalability site with lots of
data and sharding and replication and high availability and all those
buzzwords, because I'm not convinced it's the right tool for that job, but I
am convinced that its replication strategy will keep it relevant for years to
come.</p>

<h2>Redis</h2>

<p>Wow, looking at the bullet points this database seems to do just about
everything, perfectly!  Yeah, it's a bit prone to hyperbole and there are some
great things about it, but a lot of it is hot air.  For example, it claims to
support sharding but really all it does is have the client run a hash function
on its key and use that to determine which server to send its value to.  This
is something that any database can do.</p>

<p>When you get down to it, Redis is a key-value store which provides a richer
API than something like Tokyo Cabinet.  It does more operations in memory,
only periodically flushing to disk, so there's more of a risk that you could
lose data on a crash.  The tradeoff is that it's extremely fast, and it does
some neat things like allow you to append a value to the end of a list of
items already stored for a given key.</p>

<p>It also has atomic operations.  This is honestly the only reason I find this
project interesting, because the atomic operation support that it has means
that it can be turned into a best-of-breed tally server.  If you are building
a server to keep real-time counts of various things, you would be remiss to
overlook Redis as a very viable option.</p>

<h2>Cassandra</h2>

<p>It's good to save the best for last, and that's exactly what I've done as I
find Cassandra to be easily the most interesting non-relational database out
there today.  Originally developed by Facebook, it was developed by some of
the key engineers behind Amazon's famous Dynamo database.</p>

<p>Cassandra can be thought of as a huge 4-or-5-level associative array, where
each dimension of the array gets a free index based on the keys in that level.
The real power comes from that optional 5th level in the associative array,
which can turn a simple key-value architecture into an architecture where you
can now deal with sorted lists, based on an index of your own specification.
That 5th level is called a SuperColumn, and it's one of the reasons that
Cassandra stands out from the crowd.</p>

<p>Cassandra has no single points of failure, and can scale from one machine to
several thousands of machines clustered in different data centers.  It has no
central master, so any data can be written to any of the nodes in the cluster,
and can be read likewise from any other node in the cluster.</p>

<p>It provides knobs that can be tweaked to slide the scale between consistency
and availability, depending on your particular application and problem domain.
And it provides a high availability guarantee, that if one node goes down,
another node will step in to replace it smoothly.</p>

<p>Writing about all the features of Cassandra is a whole different post, but I
am convinced that its data model is rich enough to support a wide variety of
applications while providing the kind of extreme scalability and high
availability features that few other databases can achieve--all while
maintaining a lower latency than other solutions out there.</p>

<h2>Conclusion</h2>

<p>There are many other non-relational databases out there: HBase and Hypertable,
which are replicating Google's BigTable despite its complexity and problems
with single points of failure.  MongoDB is another database that has been
getting some traction, but it seems to be a jack of all trades, master of
none.  In short, the above databases are the ones that I find interesting
right now, and I would use each of them for different use cases.</p>

<p>What do you all think about this whole non-relational database thing?  Do you
agree with my thoughts or do you think I'm full of it?
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flojax: A unobtrusive and easy strategy for creating AJAX-style web applications]]></title>
    <link href="http://eflorenzano.com/blog/2009/04/02/flojax-unobtrusive-and-easy-strategy-creating-ajax/"/>
    <updated>2009-04-02T19:05:18-07:00</updated>
    <id>http://eflorenzano.com/blog/2009/04/02/flojax-unobtrusive-and-easy-strategy-creating-ajax</id>
    <content type="html"><![CDATA[<p>
Writing AJAX-style web applications can be very tedious.  If you're using XML
as your transport layer, you have to parse the XML before you can work with it.
It's a bit easier if you're using JSON, but once you have parsed the data, the
data still needs to be turned into HTML markup that matches the current markup
on the page.  Finally, the newly created markup needs to be inserted into the
correct place in the DOM, and any event handlers need to be attached to the
appropriate newly-inserted markup.</p>

<p>So there's the parsing, the markup assembly, the DOM insertion, and finally the
event handler attachment.  Most of the time, people tend to write custom code
for each element that needs asynchronous updating.  There are several drawbacks
with this scenario, but the most frustrating part is probably that the
presentation logic is implemented twice--once in a templating language on the
server which is designed specifically for outputting markup, and again on the
client with inline Javascript.  This leads to problems both in the agility and
in the maintainability of this type of application.</p>

<p>With flojax, this can all be  accomplished with one generalized implementation.
The same server-side logic that generates the data for the first synchronous
request can be used to respond to subsequent asynchronous requests, and
unobtrusive attributes specify what to do for the rest.</p>

<h2>The Basics</h2>

<p>The first component for creating an application using the flojax strategy is to
break up the content that you would like to reload asynchronously into smaller
fragments.  As a basic example of this, let's examine the case where there is a
panel of buttons that you would like to turn into asynchronous requests instead
of full page reloads.</p>

<p>The rendered markup for a fragment of buttons could look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    &lt;a href="http://eflorenzano.com/vote/up/item1/"&gt;Vote up&lt;/a&gt;
    &lt;a href="http://eflorenzano.com/vote/down/item1/"&gt;Vote down&lt;/a&gt;
    &lt;a href="http://eflorenzano.com/favorite/item1/"&gt;Add to your favorites&lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p>In a templating language, the logic might look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    {% if voted %}
        &lt;a href="http://eflorenzano.com/vote/clear/{{ item.id }}/"&gt;Clear your vote&lt;/a&gt;
    {% else %}
        &lt;a href="http://eflorenzano.com/vote/up/{{ item.id }}/"&gt;Vote up&lt;/a&gt;
        &lt;a href="http://eflorenzano.com/vote/down/{{ item.id }}/"&gt;Vote down&lt;/a&gt;
    {% endif %}
    {% if favorited %}
        &lt;a href="http://eflorenzano.com/favorite/{{ item.id }}/"&gt;Add to your favorites&lt;/a&gt;
    {% else %}
        &lt;a href="http://eflorenzano.com/unfavorite/{{ item.id }}/"&gt;Remove from your favorites&lt;/a&gt;
    {% endif %}
&lt;/div&gt;
</code></pre>

<p>(Typically you wouldn't use anchors to do operations that can change state on
the server, so you can imagine this would be accomplished using forms.  However,
for demonstration and clarity purposes I'm going to leave these as links.)</p>

<p>Now that we have written a fragment, we can start using it in our larger
templates by way of an include, which might look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>...
&lt;p&gt;If you like this item, consider favoriting or voting on it:&lt;/p&gt;
{% include "fragments/buttons.html" %}
...
</code></pre>

<p>To change this from being standard links to being asynchronously updated, we
just need to annotate a small amount of data onto the relevant links in the
fragment.</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    {% if voted %}
        &lt;a href="http://eflorenzano.com/vote/clear/{{ item.id }}/" class="flojax" rel="buttons"&gt;Clear your vote&lt;/a&gt;
    {% else %}
        &lt;a href="http://eflorenzano.com/vote/up/{{ item.id }}/" class="flojax" rel="buttons"&gt;Vote up&lt;/a&gt;
        &lt;a href="http://eflorenzano.com/vote/down/{{ item.id }}/" class="flojax" rel="buttons"&gt;Vote down&lt;/a&gt;
    {% endif %}
    {% if favorited %}
        &lt;a href="http://eflorenzano.com/favorite/{{ item.id }}/" class="flojax" rel="buttons"&gt;Add to your favorites&lt;/a&gt;
    {% else %}
        &lt;a href="http://eflorenzano.com/unfavorite/{{ item.id }}/" class="flojax" rel="buttons"&gt;Remove from your favorites&lt;/a&gt;
    {% endif %}
&lt;/div&gt;
</code></pre>

<p>That's it!  At this point, all of the click events that happen on these links
will be changed into POST requests, and the response from the server will be
inserted into the DOM in place of this div with the class of "buttons".  If you
didn't catch it, all that was done was to add the "flojax" class onto each of
the links, and add a rel attribute that refers to the class of the parent node
in the DOM to be replaced--in this case, "buttons".</p>

<p>Of course, there needs to be a server side component to this strategy, so that
instead of rendering the whole page, the server just renders the fragment.  Most
modern Javascript frameworks add a header to the request to let the server know
that the request was made asynchronously from Javascript.  Here's how the code
on the server to handle the flojax-style request might look (in a kind of
non-web-framework-specific Python code):</p>

<p>.. code-block:: python</p>

<pre><code>def vote(request, direction, item_id):
    item = get_item(item_id)

    if direction == 'clear':
        clear_vote(request.user, item)
    elif direction == 'up':
        vote_up(request.user, item)
    elif direction == 'down':
        vote_down(request.user, item)

    context = {'voted': direction != 'clear', 'item': item}

    if request.is_ajax():
        return render_to_response('fragments/buttons.html', context)

    # ... the non-ajax implementation details go here

    return render_to_response('items/item_detail.html', context)
</code></pre>

<p>There are several advantages to writing your request handlers in this way.
First, note that we were able to totally reuse the same templating logic from
before--we just render out the fragment instead of including it in a larger
template.  Second, we have provided a graceful degradation path where users
without javascript are able to interact with the site as well, albeit with a
worse user experience.</p>

<p>That's really all there is to writing web applications using the flojax
strategy.</p>

<h2>Implementation Details</h2>

<p>I don't believe that the Javascript code for this method can be easily reused,
because each web application tends to have a different way of showing errors and
other such things to the user.  In this post, I'm going to provide a reference
implementation (using jQuery) that can be used as a starting point for writing
your own versions.  The bulk of the work is done in a function that is called on
every page load, called <code>flojax_init</code>.</p>

<p>.. code-block:: javascript</p>

<pre><code>function flojax_clicked() {
    var link = $(this);
    var parent = link.parents('.' + link.attr('rel'));

    function successCallback(data, textStatus) {
        parent.replaceWith(data);
        flojax_init();
    }
    function errorCallback(request, textStatus, errorThrown) {
        alert('There was an error in performing the requested operation');
    }

    $.ajax({
        'url': link.attr('href'),
        'type': 'POST',
        'data': '',
        'success': successCallback,
        'error': errorCallback
    });

    return false;
}

function flojax_init() {
    $('a.flojax').live('click', flojax_clicked);
}
</code></pre>

<p>There's really not a lot of code there.  It POSTS to the given URL and replaces
the specified parent class with the content of the response, and then
re-initializes the flojax handler.  The re-initialization could even be done in
a smarter way, as well, by targeting only the newly inserted content.  Also, you
might imagine that an alert message probably wouldn't be such a great user
experience, so you could integrate error messages into some sort of Javascript
messaging or growl-style system.</p>

<h2>Extending Flojax</h2>

<p>Often times you'll want to do other things on the page when the asynchronous
request happens.  For our example, maybe there is some kind of vote counter that
needs to be updated or some other messages that need to be displayed.</p>

<p>In these cases, I have found that using hidden input elements in the fragments
can be useful for transferring that information from the server to the client.
As long as the value in the hidden elements adheres to some predefined structure
that your client knows about (it could even be something like JSON if you need
to go that route).</p>

<p>If what you want can't be done by extending the fragments in this way, then
flojax isn't the right strategy for that particular feature.</p>

<h2>Limitations</h2>

<p>This technique cannot solve all of the world's problems.  It can't even solve
all of the problems involved in writing an AJAX-style web application.  It can,
however, handle a fair amount of simple cases where all you want to do is
quickly set up a way for a user's action to replace content on a page.</p>

<p>Some specific examples of things that flojax can't help with are if a user
action can possibly update many items on a page, or if something needs to happen
without a user clicking on a link.  In these situations, you are better off
coding a custom solution instead of trying to shoehorn it into the flojax
workflow.</p>

<h2>Conclusion</h2>

<p>Writing AJAX-style web applications is usually tedious, but using the techniques
that I've described, a large majority of the tedious work can be reduced.  By
using the same template code for rendering the page initially as with subsequent
asynchronous requests, you ensure that code is not duplicated.  By rendering HTML
fragments, the client doesn't have to go through the effort of parsing the
output and converting the result into correct DOM objects.  Finally, by using a
few unobtrusive conventions (like the <code>rel</code> attribute and the <code>flojax</code>
class), the Javascript code that a web application developer writes is able to
be reused again and again.</p>

<p>I don't believe that any of the details that I'm describing are new.  In fact,
people have been doing most of these things for years.  What I think may in fact
be new is the generalization of the sum of these techniques in this way.  It's
still very much a work in progress, though.  As I use flojax more and more, I
hope to find not only places where it can be extended to cover more use cases,
but also its limitations and places where it makes more sense to use another
approach.</p>

<p>What do you think about this technique?  Are you using any techniques like this
for your web applications?  If so, how do they differ from what I've described?
</p>
]]></content>
  </entry>
  
</feed>
