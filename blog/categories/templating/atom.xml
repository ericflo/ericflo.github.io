<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Templating | Eric Florenzano's Blog]]></title>
  <link href="http://ericflo.github.com/blog/categories/templating/atom.xml" rel="self"/>
  <link href="http://ericflo.github.com/"/>
  <updated>2012-01-01T18:16:12-08:00</updated>
  <id>http://ericflo.github.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Interesting Discussion, Nginx]]></title>
    <link href="http://ericflo.github.com/blog/2007/08/07/interesting-discussion-nginx/"/>
    <updated>2007-08-07T22:09:21-07:00</updated>
    <id>http://ericflo.github.com/blog/2007/08/07/interesting-discussion-nginx</id>
    <content type="html"><![CDATA[<p>
<code>Very interesting discussion</code><em> going on right now about Django's templating language and whether to split it off into its own separate library.  One of the justifications is that it will "feel" easier to plug in other template languages into Django itself.  Funny how <code>I just blogged about how easy this is already</code></em>.</p>

<p>Also, previously this site was run with apache2 and perlbal.  Now it's running apache2 and nginx.  At some point I'm going to make the switch to having all of the media pointing to an nginx-only server which short circuits the mod_python (also soon to be mod_wsgi, lol) handlers altogether.</p>

<p>Sorry that this is another in a line of short posts, but I expect this trend will continue as I move twice in the next 2 weeks.  Crazy stuff happening in my life right now!</p>

<p>.. <em><code>Very interesting discussion</code>: http://groups.google.com/group/django-developers/browse_thread/thread/37801d8c2f46a313/a002ad9645e64e0a#a002ad9645e64e0a
.. </em><code>I just blogged about how easy this is already</code>: http://www.eflorenzano.com/blog/cheetah-and-django/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cheetah and Django]]></title>
    <link href="http://ericflo.github.com/blog/2007/08/03/cheetah-and-django/"/>
    <updated>2007-08-03T20:18:41-07:00</updated>
    <id>http://ericflo.github.com/blog/2007/08/03/cheetah-and-django</id>
    <content type="html"><![CDATA[<p>
Django is my preferred web development framework.  As such, I like it as a total solution: ORM, Template System, and Request/Response Mechanisms.  One of the criticisms that gets tossed around regarding Django is that it's a monolithic web framework, and as such it is not loosely coupled.  I would argue that while it is a monolithic framework, it is still loosely coupled, and I'll prove it by showing just how easy it is to replace the templating system.</p>

<p>After a quick google search for django and cheetah, I was surprised to find that there seem to be no really great examples online of the replacement of the template part of the Django stack.  That being the case, I have decided to provide some examples of how that can be accomplished.  In short, I'm going to demonstrate how to use the <code>Cheetah template language</code><em> with the <code>Django web framework</code></em>.</p>

<p>Before we delve into how to integrate Cheetah with Django, first let's look at some basic Cheetah syntax.  Basically all placeholders in cheetah templates are prefixed by $, and all control flow logic is prefaced by #.  Beyond that, mostly the syntax follows normal Python syntax.</p>

<p>If there's a python object <code>test = [1, 2, "3.1415", 4, range]</code>, the Cheetah placeholder <code>$test[0]</code> would return 1, <code>$test[2]</code> would return 3.1415, and <code>$test[4](0,$test[1])</code> would return <code>[0, 1]</code>.  To learn about control flow or any of the more advanced topics, you'll have to visit <code>the excellent Cheetah Users Guide</code>_.</p>

<p>To demonstrate using Cheetah with Django, we're going to use the canonical example: the blog.  First, the model (about the most simplistic one I could think of for a blog):</p>

<p>.. code-block:: python</p>

<pre><code>from django.db import models

class BlogPost(models.Model):
    title = models.CharField(maxlength = 128)
    body = models.TextField()

    def __unicode__(self):
        return self.title
</code></pre>

<p>Now, let's make sure to add a template folder to TEMPLATE_DIRS in settings.py:</p>

<p>.. code-block:: python</p>

<pre><code>TEMPLATE_DIRS = (
    '/path/to/myproject/templates',
)
</code></pre>

<p>Now, one aspect of Django that I've gotten really accustomed to is the render_to_response method.  It's nice to be able to specify a template name and pass in some context, and get an <code>HttpResponse</code> object back.  So we'll start by replacing that method, but for cheetah:</p>

<p>.. code-block:: python</p>

<pre><code>import os.path
from Cheetah.Template import Template
from django.conf import settings
from django.http import HttpResponse
def render_to_response(template_name, context, **kwargs):
    for template_dir in settings.TEMPLATE_DIRS:
        path = os.path.join(template_dir, template_name)
        if os.path.exists(path):
            template = Template(file = path, searchList = (context,))
            return HttpResponse(unicode(template), **kwargs)
    raise ValueError, 'Could not find template for %s' % template_name
</code></pre>

<p>This code snippet can go anywhere, but to make it easy you can just put it in your <code>views.py</code>.  As for how it works: basically we're just iterating over each template directory in <code>TEMPLATE_DIRS</code>.  If we find that a file exists, we create a cheetah Template object with that file as its base and with the specified context as its search list.  Then, we simply render the result into an <code>HttpResponse</code> object.  I feel that this solution is both simple and robust--two concepts that usually exclude each other.</p>

<p>So, how would a simple view look using our new helper render_to_response?</p>

<p>.. code-block:: python</p>

<pre><code>from myproject.blog.models import BlogPost
def index(request):
    blogs = BlogPost.objects.all()
    context = { 'blogs' : blogs }
    return render_to_response('index.tmpl', context)
</code></pre>

<p>Ok, it's going to take a bit of explaining for that last snippet.  There's a lot of advanced things going on that make it look totally unfamiliar.  But actually that's just one big lie: this looks EXACTLY like any other Django view!  We've just completely and transparently replaced the templating system of Django, and all it took was a 7-line helper function.  But we're not done yet.  We still have to write the template:</p>

<p>.. code-block:: html</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;&lt;title&gt;I can has cheetah templates!&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
    #for $post in $blogs
    &lt;div class="blogpost"&gt;
        &lt;h1&gt;$post.title&lt;/h1&gt;
        &lt;p&gt;$post.body&lt;/p&gt;
    &lt;/div&gt;
    #end for
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Now point a url to the example view, and watch the magic unfold.  I'm not a Cheetah user normally, so I can't really comment about some of the more complex features of that language, but I can't imagine that enabling them would be much more difficult than what we've already done here.  So, that means I'm totally aware that there may be some naivity in my implementation.  If so, please comment and I'll change it accordingly.</p>

<p>.. <em><code>Cheetah template language</code>: http://www.cheetahtemplate.org/
.. </em><code>Django web framework</code>: http://www.djangoproject.com/
.. _<code>the excellent Cheetah Users Guide</code>: http://www.cheetahtemplate.org/docs/users_guide_html/users_guide.html
</p>
]]></content>
  </entry>
  
</feed>
