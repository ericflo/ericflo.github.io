<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WSGI | Eric Florenzano's Blog]]></title>
  <link href="http://eflorenzano.com/blog/categories/wsgi/atom.xml" rel="self"/>
  <link href="http://eflorenzano.com/"/>
  <updated>2012-04-18T17:34:47-07:00</updated>
  <id>http://eflorenzano.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing Blazing Fast, Infinitely Scalable, Pure-WSGI Utilities]]></title>
    <link href="http://eflorenzano.com/blog/2009/01/08/writing-blazing-fast-infinitely-scalable-pure-wsgi/"/>
    <updated>2009-01-08T02:29:10-08:00</updated>
    <id>http://eflorenzano.com/blog/2009/01/08/writing-blazing-fast-infinitely-scalable-pure-wsgi</id>
    <content type="html"><![CDATA[<p>
Lately I've really fallen in love with writing utilities whose interface is
simply HTTP.  By making it accessible via HTTP, it's really easy to write
clients that talk to the utility and, if the need arises, there are lots of
tools that already exist for doing things with HTTP, like load balancing and
caching, etc.</p>

<p>While it would be easy to use a framework to build these utilities, lately I've
been choosing not to do so.  Web frameworks like Django<em> and Pylons</em> are great
when you need to build a fully-featured web application that will be accessible
by people.  When it will only be computers talking to the service, however, a
lot of the machinery provided by frameworks is unneeded and will only slow your
utility down.  Instead of using a framework, we're going to write a pure WSGI_
application.</p>

<h2>An Example: Music Discovery Website</h2>

<p>This has all been very abstract, so let's take an example: Suppose you run a
music discovery website that lets you play songs online.  Next to each song, you
simply want to display how many times the song has been played.</p>

<p>One solution to that problem could be to have a <code>play_count</code> column on the
table where the song metadata is stored.  Every time someone plays the song, you
could issue an <code>UPDATE</code> on the row and increase the <code>play_count</code> by one.
This solution will work while your site is small, but as more and more people
begin using the application, the number of writes to your database is going to
kill its performance.</p>

<p>A much more robust and scalable solution is to append a new line to a text
log file every time a song is played, and have a process run regularly to scoop
up all of the log files and update those <code>play_count</code> fields in the database.</p>

<p>However, even if you have that regular process run once every hour, there's
still too great a lag time between when a user takes an action and when they see
the results of that action.  This is where our WSGI utility comes into play. It
can serve as a realtime play counter to count the plays in between the time when
the logs are analyzed and the <code>play_count</code> columns updated.</p>

<h2>Song Play Counter</h2>

<p>We can design the interface for our WSGI song play counter utility any way that
we like, but I'm going to try to keep it as RESTful_ as I can.  The interface
will look like this:</p>

<ul>
<li><code>GET /song/SONGID</code> will return the current play count of the given song</li>
<li><code>POST /song/SONGID</code> will increment the play count of the given song by one, and return its new value</li>
<li><code>GET /</code> will return a mapping of all songs registered to their respective play counts</li>
<li><code>DELETE /</code> will clear the whole mapping</li>
</ul>


<p>So let's get started.  First, I always like to start with a very basic skeleton:</p>

<p>.. code-block:: python</p>

<pre><code>def application(environ, start_response):
    start_response('200 OK', [('content-type', 'text/plain')])
    return ('Hello world!',)
</code></pre>

<p>This does what you would imagine, returns <code>Hello world!</code> to each and every
request that it receives.  Not very useful, so let's make it more interesting:</p>

<p>.. code-block:: python</p>

<pre><code>from collections import defaultdict
counts = defaultdict(int)

def application(environ, start_response):
    global counts
    path = environ['PATH_INFO']
    method = environ['REQUEST_METHOD']
    if path.startswith('/song/'):
        song_id = path[6:]
        if method == 'GET':
            start_response('200 OK', [('content-type', 'text/plain')])
            return (str(counts[song_id]),)
        elif method == 'POST':
            counts[song_id] += 1
            start_response('200 OK', [('content-type', 'text/plain')])
            return (str(counts[song_id]),)
        else:
            start_response('405 METHOD NOT ALLOWED', [('content-type', 'text/plain')])
            return ('Method Not Allowed',)
    start_response('404 NOT FOUND', [('content-type', 'text/plain')])
    return ('Not Found',)
</code></pre>

<p>We've now added the data structure that we're using to keep track of the counts,
which in this case is a <code>defaultdict(int)</code>.  We're also now looking at the
request path and method, as well.  If it's a GET starting with /song/, we look
up the count and return it, and if it's a POST starting with /song/, we
increment it by one before returning it.  Also, we're doing the proper thing if
we detect a method that's not allowed: we're returning HTTP error code 405.</p>

<p>Now let's add the final bit of functionality:</p>

<p>.. code-block:: python</p>

<pre><code>from collections import defaultdict
counts = defaultdict(int)

def application(environ, start_response):
    # ... start of app
    if path.startswith('/song/'):
        # ... song-specific logic
    elif path == '/':
        if method == 'GET':
            res = ','.join(['%s=%s' % (k, v) for k, v in counts.iteritems()])
            start_response('200 OK', [('content-type', 'text/plain')])
            return (res,)
        elif method == 'DELETE':
            counts = defaultdict(int)
            start_response('200 OK', [('content-type', 'text/plain')])
            return ('OK',)
        else:
            start_response('405 METHOD NOT ALLOWED', [('content-type', 'text/plain')])
            return ('Method Not Allowed',)
    # ... rest of app
</code></pre>

<p>We've done basically the same thing here as we did with the previous example: we
are looking at the request path and method and doing the appropriate action.
There really is nothing very tricky going on here.  We're inventing our own
format for the case where we return the counts for all songs, but it's nothing
that will be hard to parse.</p>

<p><strong>NOTE:</strong> Generally you would want to use some sort of threading lock primitive
before accessing a global dictionary like this.  I will be using Spawning<em> to
run this WSGI</em> application, with a threadpool size of 0 to use cooperative
coroutines instead of standard threads, so I am able to get away without locks
for this application.  To install Spawning_ for yourself, just type:</p>

<p>.. code-block:: bash</p>

<pre><code>sudo easy_install Spawning
</code></pre>

<h2>Running the Utility</h2>

<p>Let's just take a quick look at how this utility works, from the command line:</p>

<p>.. code-block:: bash</p>

<pre><code>$ spawn -t 0 -p 8000 counter.application
</code></pre>

<p>...and in another window:</p>

<p>.. code-block:: bash</p>

<pre><code>$ curl http://127.0.0.1:8000/song/1
0
$ curl -X POST http://127.0.0.1:8000/song/1
1
$ curl http://127.0.0.1:8000/song/1
1
$ curl -X POST http://127.0.0.1:8000/song/5
1
$ curl -X POST http://127.0.0.1:8000/song/5
2
$ curl http://127.0.0.1:8000/
1=1,5=2
$ curl -X DELETE http://127.0.0.1:8000/
OK
</code></pre>

<p>As you can see, it seems to be working correctly. The play counter is behaving
as expected.</p>

<h2>Writing a Client to Talk to our Utility</h2>

<p>Now that we have our WSGI utility written to keep track of the counts on our
songs, we should write a client library to communicate with this server.</p>

<p>.. code-block:: python</p>

<pre><code>import httplib

class CountClient(object):
    def __init__(self, servers=['127.0.0.1:8000']):
        self.servers = servers

    def _get_server(self, song_id):
        return self.servers[song_id % len(self.servers)]

    def _song_request(self, song_id, method):
        conn = httplib.HTTPConnection(self._get_server(song_id))
        conn.request(method, '/song/%s' % (song_id,))
        resp = conn.getresponse()
        play_count = int(resp.read()) 
        conn.close()
        return play_count

    def get_play_count(self, song_id):
        return self._song_request(song_id, 'GET')

    def increment_play_count(self, song_id):
        return self._song_request(song_id, 'POST')

    def get_all_play_counts(self):
        dct = {}
        for server in self.servers:
            conn = httplib.HTTPConnection(server)
            conn.request('GET', '/')
            counts = conn.getresponse().read()
            conn.close()
            if not counts:
                continue
            dct.update(dict([map(int, pair.split('=')) for pair in counts.split(',')]))
        return dct

    def reset_all_play_counts(self):
        status = True
        for server in self.servers:
            conn = httplib.HTTPConnection(server)
            conn.request('DELETE', '/')
            resp = conn.getresponse().read()
            if resp != 'OK':
                status = False
            conn.close()
        return status
</code></pre>

<p>What we have here is a simple class that converts Python method calls to the
RESTful HTTP equivalents that we have written for our WSGI utility.  The best
part about this setup, though, is that it uses a hash based on the song_id to
determine which server to connect to.  If you only ever do per-song operations,
this setup is quite literally infinitely scalable.  You could have thousands of
servers keeping track of song counts, none of them knowing about each other.
Since the decision about which server to talk to happens on the client side,
there needs to be no communication between the servers whatsoever.</p>

<p>However, if you start to use the <code>get_all_play_counts</code> and
<code>reset_all_play_counts</code>, then eventually after many many servers are added it
will start to get slower.</p>

<p>Let's explore this client:</p>

<p>.. code-block:: pycon</p>

<pre><code>&gt;&gt;&gt; from countclient import CountClient
&gt;&gt;&gt; c = CountClient()
&gt;&gt;&gt; c.get_play_count(1)
0
&gt;&gt;&gt; c.increment_play_count(1)
1
&gt;&gt;&gt; c.increment_play_count(1)
2
&gt;&gt;&gt; c.get_play_count(1)
2
&gt;&gt;&gt; c.increment_play_count(5)
1
&gt;&gt;&gt; c.get_all_play_counts()
{1: 2, 5: 1}
&gt;&gt;&gt; c.reset_all_play_counts()
True
&gt;&gt;&gt; c.get_all_play_counts()
{}
</code></pre>

<h2>Benchmarks!</h2>

<p>I'm not a benchmarking nut in any way, shape, or form these days.  However, in
Python it's quite tough to beat pure-WSGI applications for raw speed.  Using my
MacBook Pro with a 2.5GHz Intel Core 2 Duo and 2 GB 667 MHz DDR2 SDRAM I got
these results from ApacheBench::</p>

<pre><code>e:Desktop ericflo$ ab -n 10000 http://127.0.0.1:8000/song/1
...
Concurrency Level:      1
Time taken for tests:   7.792 seconds
Complete requests:      10000
Failed requests:        0
Write errors:           0
Total transferred:      1020000 bytes
HTML transferred:       10000 bytes
Requests per second:    1283.31 [#/sec] (mean)
Time per request:       0.779 [ms] (mean)
Time per request:       0.779 [ms] (mean, across all concurrent requests)
Transfer rate:          127.83 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.1      0       2
Processing:     0    1   0.8      1      43
Waiting:        0    1   0.5      0      43
Total:          1    1   0.8      1      43
</code></pre>

<p>Take these results with a huge grain of salt, but suffice it to say, it's fast.
It would probably be even faster using <code>mod_wsgi</code><em> instead of Spawning</em>.</p>

<h2>Drawing Conclusions From This Exercise</h2>

<p>I don't want to misconstrue my standpoint on this: frameworks definitely have
their place.  There's no way you would want to write an entire user-facing
application with pure WSGI unless you were using lots of middleware and stuff
and at some point you're just recreating Pylons_.  But when you're writing a
HTTP utility like we did here, then I think that pure-WSGI is the way to go.</p>

<p>I'd like to touch on one more nice side effect of using pure-WSGI: You can run
it in any application server that supports WSGI.  That means
<code>Google App Engine</code>_, Apache, Spawning, CherryPy, and many other containers. It
can easily be served by pure python so even on very restrictive shared hosting
it's possible to run your utility.</p>

<p>What do you think of pure-WSGI utilities?  Are you using them in your app? I'd
love to hear about it--leave me a comment and tell me your thoughts on this
subject.</p>

<p>.. <em>Django: http://www.djangoproject.com/
.. </em>Pylons: http://pylonshq.com/
.. <em>WSGI: http://wsgi.org/wsgi/
.. </em>RESTful: http://en.wikipedia.org/wiki/Representational_State_Transfer
.. <em>Spawning: http://pypi.python.org/pypi/Spawning/0.7
.. </em><code>mod_wsgi</code>: http://code.google.com/p/modwsgi/
.. _<code>Google App Engine</code>: http://code.google.com/appengine/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSGI middleware is awesome, and Django should use it more]]></title>
    <link href="http://eflorenzano.com/blog/2008/11/17/wsgi-middlware-awesome-django-use-it-more/"/>
    <updated>2008-11-17T19:26:48-08:00</updated>
    <id>http://eflorenzano.com/blog/2008/11/17/wsgi-middlware-awesome-django-use-it-more</id>
    <content type="html"><![CDATA[<p>
Most people in the Django community are deploying their apps these days with
<code>mod_wsgi</code><em>.  If not, then you're at least using WSGI</em> as a communication layer
with your application server, in one way or another.  The great thing about
WSGI is that it gives everyone a common interface through which to talk.  It
also has the added benefit of being a common abstraction that many people have
built these great, really useful tools on top of.</p>

<p>Consider Repoze<em>.  If you navigate to the <code>middleware section</code></em> of their
website, they have some really cool stuff available!  There are utilities for
logging, authentication, security, profiling, templating, etc.  All of these
pieces of middleware are designed to be totally pluggable, because they are
designed to work solely based on what's available through WSGI.</p>

<p>My personal favorite of that lot is <code>repoze.profile</code>.  It accumulates
Python profiling information about whatever app is being run, and allows you to
view that profile information via a web interface by visiting a special URL.
There is absolutely no reason that the Pylons, TurboGears, or CherryPy guys
should be able to get away with keeping this stuff for themselves, so I want to
show just how easy it is to integrate this profiling module with Django.</p>

<p>First, though, here's a typical .wsgi file that might be used in conjunction
with <code>mod_wsgi</code>:</p>

<p>.. code-block:: python</p>

<pre><code>import os, sys
sys.stdout = sys.stderr

os.environ['DJANGO_SETTINGS_MODULE'] = 'settings'

import django.core.handlers.wsgi

application = django.core.handlers.wsgi.WSGIHandler()
</code></pre>

<p>There's really nothing special going on here, and if you would like to learn
more about how to set up this WSGI file, visit
<code>mod_wsgi's documentation on the subject</code>_.  Now if you'll notice,
<code>application</code> is simply an instance of <code>WSGIHandler</code>, which is simply a
callable.  A WSGI middleware is just a wrapper around that callable.  Here's how
easy it is to add the profiling middleware:</p>

<p>.. code-block:: python</p>

<pre><code>from repoze.profile.profiler import AccumulatingProfileMiddleware
application = AccumulatingProfileMiddleware(
    application,
    log_filename='/tmp/djangoprofile.log',
    discard_first_request=True,
    flush_at_shutdown=True,
    path='/__profile__')
</code></pre>

<p>There we go!  We have imported the profiling middleware, and passed the Django
WSGI application as the first argument.  The rest is just setting options for
the middleware.  You can restart apache and the WSGI profiling middleware is
already working.</p>

<p>Sometimes, though, you don't want all of Apache just to run some middleware.
You want to be able to do the same thing, but locally.  Believe it or not,
Django's local development server is just a WSGI server itself, so one option
would be to do the wrapping directly in django, <code>right here</code><em>.  But you really
don't want to be hacking inside of Django internals if you don't have to.
Fortunately there are many alternative WSGI servers out there.  Brian Rosner
has created a custom management command to use the excellent CherryPy WSGI
server with Django, on <code>his blog</code></em>.</p>

<p>Let's say you just want to try this out quickly after reading this blog post,
though.  If you're running Python 2.5 or greater, you're in luck, because a
script less than 10 lines long can get you up and running:</p>

<p>.. code-block:: python</p>

<pre><code>#!/usr/bin/env python

import sys
from wsgiref.simple_server import make_server

if __name__ == "__main__":
    execfile(sys.argv[1])
    httpd = make_server('', 8000, application)
    httpd.serve_forever()
</code></pre>

<p>Now, to run it, simply invoke it like this:</p>

<p>.. code-block:: bash</p>

<pre><code>python runserver.py my_wsgi_file.wsgi
</code></pre>

<p>Now, navigate around your app for a little bit and then point your browser to
<code>the profile url</code>_ and see how freaking awesome middleware can be.</p>

<p>I'm not trying to stir up any controversy, I'm not saying we should stop making
Django middleware or anything like that.  But I seriously, seriously hope that
someone tries this out and realizes the multitudes of great WSGI apps out there
that can be taken advantage of.  <code>Mark Ramm</code><em> wasn't full of hot air when he
talked about this at DjangoCon or <code>blogged about it</code></em> later.  He was right, and
I for one wish I had listened sooner.</p>

<p>.. <em><code>mod_wsgi</code>: http://code.google.com/p/modwsgi/
.. </em>WSGI: http://wsgi.org/wsgi/
.. <em>Repoze: http://repoze.org/
.. </em><code>middleware section</code>: http://repoze.org/repoze_components.html#middleware
.. <em><code>mod_wsgi's documentation on the subject</code>: http://code.google.com/p/modwsgi/wiki/IntegrationWithDjango
.. </em><code>right here</code>: http://code.djangoproject.com/browser/django/trunk/django/core/management/commands/runserver.py#L60
.. <em><code>his blog</code>: http://oebfare.com/blog/2008/nov/03/writing-custom-management-command/
.. </em><code>the profile url</code>: http://localhost:8000/<strong>profile</strong>
.. <em><code>Mark Ramm</code>: http://compoundthinking.com/blog/
.. </em><code>blogged about it</code>: http://compoundthinking.com/blog/index.php/2008/10/06/wsgi-middleare-is-cool/
</p>
]]></content>
  </entry>
  
</feed>
