<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Triggers | Eric Florenzano's Blog]]></title>
  <link href="http://eflorenzano.com/blog/categories/triggers/atom.xml" rel="self"/>
  <link href="http://eflorenzano.com/"/>
  <updated>2012-04-18T17:34:47-07:00</updated>
  <id>http://eflorenzano.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Database triggers aren't evil, and they actually kind of rock]]></title>
    <link href="http://eflorenzano.com/blog/2008/11/03/database-triggers-arent-evil-and-they-actually-kin/"/>
    <updated>2008-11-03T18:44:19-08:00</updated>
    <id>http://eflorenzano.com/blog/2008/11/03/database-triggers-arent-evil-and-they-actually-kin</id>
    <content type="html"><![CDATA[<p></p>

<h2>Who says they suck?</h2>

<p>Nobody that I've seen has come out and actually said that they don't like
database triggers, but at the same time, Python (Django) programmers like to
program in Python.  And PL/pgSQL certainly is not Python.  There's a tendency to
do everything in Python--especially with the use of Django's dispatcher.</p>

<p>But there's some serious overhead with that approach, and roundtrips, and race
conditions, etc.  If you're using a good database, there's an alternative:
you guessed it, database triggers.</p>

<h2>Let's set up some models</h2>

<p>Here will be our models for the remainder of this post:</p>

<p>.. code-block:: python</p>

<pre><code>class Bookmark(models.Model):
    title = models.CharField(max_length=100)
    url = models.URLField(max_length=255)

    num_votes = models.PositiveIntegerField(null=True, blank=True, default=0)
    score = models.IntegerField(null=True, blank=True, default=0)

class Vote(models.Model):
    bookmark = models.ForeignKey(Bookmark, related_name='votes')
    value = models.IntegerField()
</code></pre>

<p>As you can tell, we have a straightforward <code>Bookmark</code> and <code>Vote</code> models here.
But there are also two denormalized fields: <code>num_votes</code>, and <code>score</code>.</p>

<h2>Doing it in Python</h2>

<p>The advantage of doing this in Python is that it's simple and Django supports
it out of the box.  Here's how the code for that would look:</p>

<p>.. code-block:: python</p>

<pre><code>from django.db.models import signals

def update_bookmark_aggregate(sender, instance, **kwargs):
    bmark = instance.bookmark
    bmark.num_votes = bmark.votes.count()
    bmark.score = sum(bmark.votes.values_list('value', flat=True))
    bmark.save(force_update=True)
signals.post_save.connect(update_bookmark_aggregate, sender=Vote)
</code></pre>

<p>Very simply, every time a vote is saved, the <code>update_bookmark_aggregate</code>
function is called which updates the bookmark with its new score and num_votes.</p>

<h2>Doing it in Pl/pgSQL</h2>

<p>Create a new file, named <code>management.py</code> under your bookmarks app directory.
Its contents will be as follows:</p>

<p>.. code-block:: python</p>

<pre><code>from django.db.models import signals
from bookmarks import models

sql = """
CREATE LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION update_bookmark_aggregate_trigger()
    RETURNS "trigger" AS '
    DECLARE
        new_score INTEGER;
        new_num_votes INTEGER;
    BEGIN
        SELECT COUNT(*) INTO STRICT new_num_votes FROM bookmarks_vote
            WHERE bookmark_id = NEW.bookmark_id;
        SELECT COALESCE(SUM(value), 0) INTO STRICT new_score FROM bookmarks_vote
            WHERE bookmark_id = NEW.bookmark_id;
    UPDATE bookmarks_bookmark 
        SET
            score = new_score,
            num_votes = new_num_votes
        WHERE id = NEW.bookmark_id;
    RETURN NEW;
    END;' LANGUAGE 'plpgsql' VOLATILE;

CREATE TRIGGER update_bookmark_aggregate_trigger AFTER INSERT OR UPDATE
    ON bookmarks_vote FOR EACH ROW
    EXECUTE PROCEDURE update_bookmark_aggregate_trigger();
"""

def create_trigger(app, created_models, verbosity, **kwargs):
    from django.db import connection
    cursor = connection.cursor()
    cursor.execute(sql)
signals.post_syncdb.connect(create_trigger, sender=models)
</code></pre>

<p>In this file we have declared two variables, <code>new_score</code>, and
<code>new_num_votes</code>.  We do two queries to get the aggregate data.  And then we
update the bookmark to reflect the new aggregated values.  This script is
executed once when the bookmarks models are first loaded into the database, and
we're all set!</p>

<h2>Let's see how it works</h2>

<p>.. code-block:: pycon</p>

<pre><code>&gt;&gt;&gt; from bookmarks.models import Bookmark, Vote
&gt;&gt;&gt; b = Bookmark.objects.create(title="Blog", url='http://eflorenzano.com/')
&gt;&gt;&gt; b.num_votes
0
&gt;&gt;&gt; b.score
0
# There is no aggregate data yet
&gt;&gt;&gt; Vote.objects.create(bookmark=b, value=1)
&lt;Vote: Vote object&gt;
&gt;&gt;&gt; Vote.objects.create(bookmark=b, value=2)
&lt;Vote: Vote object&gt;
# We need to re-query for the bookmark, due to no identity map in Django.
&gt;&gt;&gt; b = Bookmark.objects.all()[0]
&gt;&gt;&gt; b.num_votes
2
&gt;&gt;&gt; b.score
3
</code></pre>

<p>Voila!  This was all done in the database behind the scenes.  Very cool, very
fast, and it kind of rocks.
</p>
]]></content>
  </entry>
  
</feed>
