<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web Hooks | Eric Florenzano's Blog]]></title>
  <link href="http://eflorenzano.com/blog/categories/web-hooks/atom.xml" rel="self"/>
  <link href="http://eflorenzano.com/"/>
  <updated>2012-04-18T17:34:47-07:00</updated>
  <id>http://eflorenzano.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reverse HTTP]]></title>
    <link href="http://eflorenzano.com/blog/2008/11/27/reverse-http/"/>
    <updated>2008-11-27T10:31:05-08:00</updated>
    <id>http://eflorenzano.com/blog/2008/11/27/reverse-http</id>
    <content type="html"><![CDATA[<p>
Yesterday I <code>wrote about Web Hooks</code>_ and how powerful it could be if one web
service sends HTTP requests to another web service.  Today I want to take that
concept one step further.  What if you tell that service that you would like it
to send a POST request back to <strong>you</strong>, whenever an event happens?  This slight
modification makes for a very powerful tool.</p>

<p>Let's take the example of popular real-time web applications like Facebook's
instant messenger or FriendFeed's "Real-time" view.  Both of these services make
use of a technique called <code>long polling</code>_, where the client sends an HTTP
request and the server does not respond until it has some event to deliver.  The
client can only keep the request open for so long, so it periodically times out
and re-sends the request. (It also re-sends the request if it does receive some
data).</p>

<p>The problem with this technique is that it's really trying to turn a client into
a server.  It's really fighting against the way that HTTP wants to work.  So why
fight it?  Imagine that all of our browsers have simple, lightweight, HTTP
servers installed.  The client could request to upgrade to reverse HTTP, and
then the <em>server</em> could initiate a connection with the <em>client</em>.  Now, as events
come in to the web service, the service could directly send those updates to the
client.</p>

<p>Going back to the example of Facebook IM, here's how that would work: When I
open a Facebook page, my client sends a request to Facebook's IM server.
Facebook's IM server sends a response with the HTTP/1.1 Upgrade header reading
"PTTH/0.9"  (funny, huh?).  Then, the client knows to accept an HTTP connection
from Facebook's IM server.  Facebook's IM server then opens that connection with
the client, and sends HTTP POSTs every time it receives a new instant message
that the client should receive.  The client's web browser would have some
JavaScript hooks to parse the body of those requests, so that it could update
the content of the instant message window on the page.</p>

<p>Isn't this brilliant?  It directly meshes with the HTTP protocol, and makes this
system which seems like a hack right now, instantly become an elegant solution.
I really wish I could take credit for thinking this up, but I did not.  My
coworker <code>Donovan Preston</code><em> blew my mind with this a few weeks back.  If you're
looking for a more visual example of how this might work, or a reference
implementation of the protocol in action, check out <code>this wiki page</code></em>.</p>

<p>.. <em><code>wrote about Web Hooks</code>: http://www.eflorenzano.com/blog/post/web-hooks/
.. </em><code>long polling</code>: http://cometdaily.com/2007/11/16/more-on-long-polling/
.. <em><code>Donovan Preston</code>: http://ulaluma.com/pyx/
.. </em><code>this wiki page</code>: http://wiki.secondlife.com/wiki/Reverse_HTTP
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["Web Hooks"]]></title>
    <link href="http://eflorenzano.com/blog/2008/11/26/web-hooks/"/>
    <updated>2008-11-26T20:43:30-08:00</updated>
    <id>http://eflorenzano.com/blog/2008/11/26/web-hooks</id>
    <content type="html"><![CDATA[<p>
A few months back GitHub<em> rolled out its implementation of something that they
call "Service Hooks".  The idea behind these hooks is that when you commit
some new piece of code to GitHub, they want to be able to alert other services
that you have committed that code.  For example, one of the service hooks is
the ability to send a tweet to Twitter, and another of those hooks updates the
Lighthouse</em> ticket tracker.</p>

<p>I thought this was a really good idea when they rolled it out, so I did a bit of
searching and found out that there is a larger body of work surrounding this
idea, and that body of work is called <code>Web Hooks</code>_.  The central idea behind
web hooks is that a user supplies a service that they use with a URL.  Then,
when that user performs an action on that service, the service agrees to send an
HTTP POST request to the user's specified URL, with some information about the
action that the user took on the service.</p>

<p>SlideShare has an excellent presentation_ deck about this idea, which likens it
to Unix pipes.  That analogy makes a lot of sense if you think about it.  With
the standard model that most websites follow today, a client can only send
requests.  This means repeated polling until the client receives the information
that it is interested in.  With web hooks, however, the service is responsible
for passing that action along to the next service.  This simple yet powerful
mechanism can allow for very advanced systems which interoperate very simply
through chaining.</p>

<p>Let's expore a concrete example of what this might look like.  A few months back
I signed up for a pro account on Flickr<em>, so that I could upload some of the
pictures that I had stored on my computer.  What I did was to upload some
pictures with descriptions, and then I went and posted on Twitter some of the
links to those pictures.  I also went and added that new Flickr account to
FriendFeed</em> so that others could see my pictures as well.</p>

<p>This was all a manual process.  If both Flickr and Twitter supported web hooks,
I could have simply set up their respective URLs and uploaded my pictures.  The
process might have happened like this:  First, the pictures are uploaded.  Then
Flickr sends a POST request to Twitter, with the description of the picture and
a link to the picture.  Twitter sends a POST request to FriendFeed, adding the
new item to my FriendFeed lifestream.</p>

<p>You could even write custom scripts to handle the web hooks. For example let's
say that I want any tweet with the name 'Kevin' to be sent to my brother's email
address.  I could add a URL to Twitter linking to a script on my computer which
scans the contents of the tweet.  If the tweet has the name 'Kevin' in it, it
would send an email.  If not, it might do nothing.</p>

<p>I think that this concept is very powerful not only in terms of rendering
trivial the interoperability between disparate services, but also in terms of
simply saving on bandwidth and computing power.  Technologies which constantly
poll resources hoping for updated content seem silly in comparison to the
powerful simplicity that web hooks provide.</p>

<p>There are definitely some drawbacks to a system like this.  Firstly, the name: I
actually can't think of a worse name for this concept.  Web hooks?!  Let's come
up with something better.  All joking aside though, this type of system does
face a serious problem when it comes to the question of reliability.  If a
script receives no POST, it could mean that either no event happened, or that
the internet connection went down for a bit, or that the service is down, or any
number of other possible things.  I think the solution for this is a hybrid
model of sparse polling in conjunction with web hooks.</p>

<p>Most of all, this technology just seems so underused.  There are ridiculously
few people who implement something like this, yet it seems like an undeniably
useful service--especially given its relative simplicity to implement.  Let's
all try to encourage the services that we use on a daily basis to support web
hooks, because by doing just that, we can make the web a lot better.</p>

<p>.. <em>GitHub: http://github.com/
.. </em>Lighthouse: http://lighthouseapp.com/
.. <em><code>Web Hooks</code>: http://webhooks.pbwiki.com/
.. </em>presentation: http://www.slideshare.net/progrium/web-hooks
.. <em>Flickr: http://flickr.com/
.. </em>FriendFeed: http://friendfeed.com/
</p>
]]></content>
  </entry>
  
</feed>
