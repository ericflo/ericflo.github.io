<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Eric Florenzano's Blog]]></title>
  <link href="http://ericflo.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://ericflo.github.com/"/>
  <updated>2011-12-31T23:20:33-08:00</updated>
  <id>http://ericflo.github.com/</id>
  <author>
    <name><![CDATA[Eric Florenzano]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why node.js disappoints me]]></title>
    <link href="http://ericflo.github.com/blog/2010/09/27/why-node-disappoints-me/"/>
    <updated>2010-09-27T01:23:47-07:00</updated>
    <id>http://ericflo.github.com/blog/2010/09/27/why-node-disappoints-me</id>
    <content type="html"><![CDATA[<p>
<code>Node.js</code>_ is currently at the center of a huge cyclone of hype.  At this point it's clear that Node is going to be a major player in the next few years of web development.  It's no wonder, either!  It represents a fresh start, one with no legacy synchronous baggage in our increasingly asynchronous, increasingly real-time web. And it's accessible to anyone who's written JavaScript (read: all web developers.)</p>

<p>Oh, and those benchmarks!  Compared trivially to the currently popular web technologies, it seems an obvious leap forward.</p>

<p>Yet one of Node's advantages that you'll hear repeated again and again by its proponents is that you can now code in One Language, and you won't have to deal with the cognitive load of context switching between different languages.  Especially as ORMs and NoSQL continue to rise in popularity, there's no need to even deal with SQL. At the end of the day you're writing JavaScript, HTML, and CSS, and that's it.</p>

<p>Seeing this happen with all of these pieces falling into place--a fresh start with a unified language--I started to get excited.  This would change the way we thought about our web code.  The frontend is the backend is the query language is the storage layer is JavaScript!  It's a revolution.</p>

<p>And then I saw what people did with this opportunity.  They effectively ported Sinatra/Django/Rails to JavaScript--and did it in such a way that it would only run on the server, with a specific feature set of JavaScript that only Node can reasonably understand.</p>

<p>Not exactly the revolution I was hoping for.</p>

<p>Instead of coding in one language, we're actually coding in two. One is the subset JavaScript that can be run in all browsers, and another is the set of JavaScript that can be run by Node.  Knowing the difference between the two languages and context switching between them is simply a required skill.</p>

<p>You know what would be awesome? If we wrote our libraries so that they could run either on the server or on the client, and they did so in a transparent way.  Maybe it would help to give a concrete example of how this could be awesome.  Let's talk about HTML templating.</p>

<p>Imagine a framework where the first page-load was always rendered server-side, meaning the client gets a single fully-rendered page.  Then for desktop browsers, browsing around the site just made calls to API endpoints returning JSON or XML, and the client rendered the templates for the changed portions of the page.  For mobile browsers with less power or for search engines, the rendering would always be done on the server.  Imagine that the templating library could record some key metrics to determine how long things were taking to render, and dynamically switch between rendering on the server and client based on server load or client speed.</p>

<p>Imagine a case where a back-end service fails temporarily.  In this case the rendering of that particular component could be deferred, the browser could be told to poll a resource.  When the back-end service is recovered, it could send the data for the client to render on its own.</p>

<p>How awesome would that be?</p>

<p>It's not just HTML templating, either.  This same principle could be applied to any number of things: URL routing, form validation, hell even most application logic could be done using this style.</p>

<p>But it's going to take discipline.  Instead of reaching for those fancy V8 features, code will need to be written in a strict subset of the JavaScript that's available.  Maybe Node could detect incompatible code and throw warnings, that would be cool.</p>

<p>I just really hope that someday we stop re-inventing the same exact wheel, and instead build something substantially different and better.</p>

<p>.. _<code>Node.js</code>: http://nodejs.org/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flojax: A unobtrusive and easy strategy for creating AJAX-style web applications]]></title>
    <link href="http://ericflo.github.com/blog/2009/04/02/flojax-unobtrusive-and-easy-strategy-creating-ajax/"/>
    <updated>2009-04-02T19:05:18-07:00</updated>
    <id>http://ericflo.github.com/blog/2009/04/02/flojax-unobtrusive-and-easy-strategy-creating-ajax</id>
    <content type="html"><![CDATA[<p>
Writing AJAX-style web applications can be very tedious.  If you're using XML
as your transport layer, you have to parse the XML before you can work with it.
It's a bit easier if you're using JSON, but once you have parsed the data, the
data still needs to be turned into HTML markup that matches the current markup
on the page.  Finally, the newly created markup needs to be inserted into the
correct place in the DOM, and any event handlers need to be attached to the
appropriate newly-inserted markup.</p>

<p>So there's the parsing, the markup assembly, the DOM insertion, and finally the
event handler attachment.  Most of the time, people tend to write custom code
for each element that needs asynchronous updating.  There are several drawbacks
with this scenario, but the most frustrating part is probably that the
presentation logic is implemented twice--once in a templating language on the
server which is designed specifically for outputting markup, and again on the
client with inline Javascript.  This leads to problems both in the agility and
in the maintainability of this type of application.</p>

<p>With flojax, this can all be  accomplished with one generalized implementation.
The same server-side logic that generates the data for the first synchronous
request can be used to respond to subsequent asynchronous requests, and
unobtrusive attributes specify what to do for the rest.</p>

<h2>The Basics</h2>

<p>The first component for creating an application using the flojax strategy is to
break up the content that you would like to reload asynchronously into smaller
fragments.  As a basic example of this, let's examine the case where there is a
panel of buttons that you would like to turn into asynchronous requests instead
of full page reloads.</p>

<p>The rendered markup for a fragment of buttons could look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    &lt;a href="http://ericflo.github.com/vote/up/item1/"&gt;Vote up&lt;/a&gt;
    &lt;a href="http://ericflo.github.com/vote/down/item1/"&gt;Vote down&lt;/a&gt;
    &lt;a href="http://ericflo.github.com/favorite/item1/"&gt;Add to your favorites&lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p>In a templating language, the logic might look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    {% if voted %}
        &lt;a href="http://ericflo.github.com/vote/clear/{{ item.id }}/"&gt;Clear your vote&lt;/a&gt;
    {% else %}
        &lt;a href="http://ericflo.github.com/vote/up/{{ item.id }}/"&gt;Vote up&lt;/a&gt;
        &lt;a href="http://ericflo.github.com/vote/down/{{ item.id }}/"&gt;Vote down&lt;/a&gt;
    {% endif %}
    {% if favorited %}
        &lt;a href="http://ericflo.github.com/favorite/{{ item.id }}/"&gt;Add to your favorites&lt;/a&gt;
    {% else %}
        &lt;a href="http://ericflo.github.com/unfavorite/{{ item.id }}/"&gt;Remove from your favorites&lt;/a&gt;
    {% endif %}
&lt;/div&gt;
</code></pre>

<p>(Typically you wouldn't use anchors to do operations that can change state on
the server, so you can imagine this would be accomplished using forms.  However,
for demonstration and clarity purposes I'm going to leave these as links.)</p>

<p>Now that we have written a fragment, we can start using it in our larger
templates by way of an include, which might look something like this:</p>

<p>.. code-block:: html</p>

<pre><code>...
&lt;p&gt;If you like this item, consider favoriting or voting on it:&lt;/p&gt;
{% include "fragments/buttons.html" %}
...
</code></pre>

<p>To change this from being standard links to being asynchronously updated, we
just need to annotate a small amount of data onto the relevant links in the
fragment.</p>

<p>.. code-block:: html</p>

<pre><code>&lt;div class="buttons"&gt;
    {% if voted %}
        &lt;a href="http://ericflo.github.com/vote/clear/{{ item.id }}/" class="flojax" rel="buttons"&gt;Clear your vote&lt;/a&gt;
    {% else %}
        &lt;a href="http://ericflo.github.com/vote/up/{{ item.id }}/" class="flojax" rel="buttons"&gt;Vote up&lt;/a&gt;
        &lt;a href="http://ericflo.github.com/vote/down/{{ item.id }}/" class="flojax" rel="buttons"&gt;Vote down&lt;/a&gt;
    {% endif %}
    {% if favorited %}
        &lt;a href="http://ericflo.github.com/favorite/{{ item.id }}/" class="flojax" rel="buttons"&gt;Add to your favorites&lt;/a&gt;
    {% else %}
        &lt;a href="http://ericflo.github.com/unfavorite/{{ item.id }}/" class="flojax" rel="buttons"&gt;Remove from your favorites&lt;/a&gt;
    {% endif %}
&lt;/div&gt;
</code></pre>

<p>That's it!  At this point, all of the click events that happen on these links
will be changed into POST requests, and the response from the server will be
inserted into the DOM in place of this div with the class of "buttons".  If you
didn't catch it, all that was done was to add the "flojax" class onto each of
the links, and add a rel attribute that refers to the class of the parent node
in the DOM to be replaced--in this case, "buttons".</p>

<p>Of course, there needs to be a server side component to this strategy, so that
instead of rendering the whole page, the server just renders the fragment.  Most
modern Javascript frameworks add a header to the request to let the server know
that the request was made asynchronously from Javascript.  Here's how the code
on the server to handle the flojax-style request might look (in a kind of
non-web-framework-specific Python code):</p>

<p>.. code-block:: python</p>

<pre><code>def vote(request, direction, item_id):
    item = get_item(item_id)

    if direction == 'clear':
        clear_vote(request.user, item)
    elif direction == 'up':
        vote_up(request.user, item)
    elif direction == 'down':
        vote_down(request.user, item)

    context = {'voted': direction != 'clear', 'item': item}

    if request.is_ajax():
        return render_to_response('fragments/buttons.html', context)

    # ... the non-ajax implementation details go here

    return render_to_response('items/item_detail.html', context)
</code></pre>

<p>There are several advantages to writing your request handlers in this way.
First, note that we were able to totally reuse the same templating logic from
before--we just render out the fragment instead of including it in a larger
template.  Second, we have provided a graceful degradation path where users
without javascript are able to interact with the site as well, albeit with a
worse user experience.</p>

<p>That's really all there is to writing web applications using the flojax
strategy.</p>

<h2>Implementation Details</h2>

<p>I don't believe that the Javascript code for this method can be easily reused,
because each web application tends to have a different way of showing errors and
other such things to the user.  In this post, I'm going to provide a reference
implementation (using jQuery) that can be used as a starting point for writing
your own versions.  The bulk of the work is done in a function that is called on
every page load, called <code>flojax_init</code>.</p>

<p>.. code-block:: javascript</p>

<pre><code>function flojax_clicked() {
    var link = $(this);
    var parent = link.parents('.' + link.attr('rel'));

    function successCallback(data, textStatus) {
        parent.replaceWith(data);
        flojax_init();
    }
    function errorCallback(request, textStatus, errorThrown) {
        alert('There was an error in performing the requested operation');
    }

    $.ajax({
        'url': link.attr('href'),
        'type': 'POST',
        'data': '',
        'success': successCallback,
        'error': errorCallback
    });

    return false;
}

function flojax_init() {
    $('a.flojax').live('click', flojax_clicked);
}
</code></pre>

<p>There's really not a lot of code there.  It POSTS to the given URL and replaces
the specified parent class with the content of the response, and then
re-initializes the flojax handler.  The re-initialization could even be done in
a smarter way, as well, by targeting only the newly inserted content.  Also, you
might imagine that an alert message probably wouldn't be such a great user
experience, so you could integrate error messages into some sort of Javascript
messaging or growl-style system.</p>

<h2>Extending Flojax</h2>

<p>Often times you'll want to do other things on the page when the asynchronous
request happens.  For our example, maybe there is some kind of vote counter that
needs to be updated or some other messages that need to be displayed.</p>

<p>In these cases, I have found that using hidden input elements in the fragments
can be useful for transferring that information from the server to the client.
As long as the value in the hidden elements adheres to some predefined structure
that your client knows about (it could even be something like JSON if you need
to go that route).</p>

<p>If what you want can't be done by extending the fragments in this way, then
flojax isn't the right strategy for that particular feature.</p>

<h2>Limitations</h2>

<p>This technique cannot solve all of the world's problems.  It can't even solve
all of the problems involved in writing an AJAX-style web application.  It can,
however, handle a fair amount of simple cases where all you want to do is
quickly set up a way for a user's action to replace content on a page.</p>

<p>Some specific examples of things that flojax can't help with are if a user
action can possibly update many items on a page, or if something needs to happen
without a user clicking on a link.  In these situations, you are better off
coding a custom solution instead of trying to shoehorn it into the flojax
workflow.</p>

<h2>Conclusion</h2>

<p>Writing AJAX-style web applications is usually tedious, but using the techniques
that I've described, a large majority of the tedious work can be reduced.  By
using the same template code for rendering the page initially as with subsequent
asynchronous requests, you ensure that code is not duplicated.  By rendering HTML
fragments, the client doesn't have to go through the effort of parsing the
output and converting the result into correct DOM objects.  Finally, by using a
few unobtrusive conventions (like the <code>rel</code> attribute and the <code>flojax</code>
class), the Javascript code that a web application developer writes is able to
be reused again and again.</p>

<p>I don't believe that any of the details that I'm describing are new.  In fact,
people have been doing most of these things for years.  What I think may in fact
be new is the generalization of the sum of these techniques in this way.  It's
still very much a work in progress, though.  As I use flojax more and more, I
hope to find not only places where it can be extended to cover more use cases,
but also its limitations and places where it makes more sense to use another
approach.</p>

<p>What do you think about this technique?  Are you using any techniques like this
for your web applications?  If so, how do they differ from what I've described?
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The most widely available virtual machine]]></title>
    <link href="http://ericflo.github.com/blog/2008/11/22/most-widely-available-virtual-machine/"/>
    <updated>2008-11-22T21:37:57-08:00</updated>
    <id>http://ericflo.github.com/blog/2008/11/22/most-widely-available-virtual-machine</id>
    <content type="html"><![CDATA[<p>
A few months back, I had a bit of an epiphany.  I suspect I was about 5 years
too late with this epiphany, but nevertheless here it is: Microsoft,
Sun, and Adobe all have these virtual machines that they want everyone to
develop on top of.  For Microsoft it's the CLR<em>, for Sun it's the JVM</em>, and for
Adobe it's AVM_.  The problem that each of them have is that not everyone goes
out of their way to install all of these VMs, so each vendor only has a subset
of the entire computing space.</p>

<p>My epiphany was that there is one VM which nearly every modern computer has
access to.  It's JavaScript.  Every browser developed in the past 10 years
ships with some variation of it, and some systems even come with it as a
command-line option.  Whilst they do have a big problem in terms of
standardization (or lack thereof), there is certainly a lowest common
denominator that could be useful for writing apps on top of.</p>

<p>That being the case, why don't we see more language implementations on top of
JavaScript?  There is Processing.js<em>, a port of the Processing</em> programming
language.  There is also <code>Objective J and Cappuccino</code>_, a port of Objective C
and Cocoa, respectively.  Each of those language implementations have received
quite a bit of attention (both positive and negative, mind you).</p>

<p>So why don't we see Ruby, Python, or other languages implemented on top of
JavaScript?  For that matter, why don't we see more ports of apps to JavaScript?
I know that in the Python world, PyPy has a JavaScript backend, but to the best
of my knowledge that backend has been all-but-abandoned.  I think it would be
really cool if we were to see more applications and programming languages
targeting the most widely adopted virtual machine ever: JavaScript.</p>

<p>.. <em>CLR: http://en.wikipedia.org/wiki/Common_Language_Runtime
.. </em>JVM: http://en.wikipedia.org/wiki/Java_virtual_machine
.. <em>AVM: http://www.adobe.com/devnet/actionscript/
.. </em>Processing.js: http://ejohn.org/blog/processingjs/
.. <em>Processing: http://processing.org/
.. </em><code>Objective J and Cappuccino</code>: http://cappuccino.org/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Are pure client-side web apps the wave of the future?]]></title>
    <link href="http://ericflo.github.com/blog/2008/11/21/are-pure-client-side-web-apps-wave-future/"/>
    <updated>2008-11-21T19:11:49-08:00</updated>
    <id>http://ericflo.github.com/blog/2008/11/21/are-pure-client-side-web-apps-wave-future</id>
    <content type="html"><![CDATA[<p>
It seems that the world of computing is always oscillating between offloading
more work to the server, and offloading more work to the client.  In the very
early days of dumb terminals, we had most of the actual computation being done
on big mainframes.  Then personal computers became more powerful, allowing for
much richer applications to be created.</p>

<p>With the advent of the internet, the landscape of computing architectures
shifted again to being done focused on the server.  Now, however, JavaScript has
become more powerful.  Combined with things like SVG and the canvas tag, we can
create extremely rich applications that take place solely in the browser.</p>

<p>Projects like CouchDB<em> are even starting to open the door for
<code>truly peer-to-peer web applications</code></em>.  With all of this taking place, it seems
that client-side web applications are poised to see some fairly strong growth.
This is especially evident now that companies as big as Google seem interested
in the idea, with its <code>Google Gears</code>_ product that allows you to "work offline".
But there are certain things that need to be satisfied first.</p>

<p>We need a way of enforcing security across these apps.  It looks like some
combination of OpenID and OAuth are going to be the winners in this space, but
I've never seen a seamless implementation of either of these protocols, even by
the companies most invested in the technology.  There is a lot of work to go on
usability before authentication and authorization are ubiquitous through these
open protocols.</p>

<p>We also need to standardize more on the data interchange formats that we use to
shuttle information back and forth between these different apps.  Atom_ goes a
long way towards describing the data that we use, but its adoption is nowhere
near ubiquitous, and some sites still rely on older, more outdated, RSS
syndication formats that aren't quite up to the task.</p>

<p>But even if we standardize on some application platform (be it Google Gears or
CouchDB or some other container), security, and data interchange formats, there
are certain things that need to be considered.  For one, there are some
applications that just aren't practical to be implemented on the client.  Video
editing comes to mind (and I would know, considering I interned for eyespot_, a
company which was attempting to do just that).</p>

<p>Another concern is that, as we've seen with the emergence of standards for CSS
and HTML, a certain amount of rigidness is good, but a strict conformist
attitude leads to significantly stifled innovation.  If you were to write an app
that doesn't fall within the boundaries of what's possible given the agreed-upon
standards, would you still be able to go forward with the development of the
app, or would you run into resistance from those who have a stake in those
standards?</p>

<p>In all, I have a feeling that we are going to move more and more to a hybrid
approach, with much more logic being computed on the side of the client
(especially in terms of visual components and interactivity), and that much more
of the server side is going to be involved in slicing and serving up just the
raw data.  We can see this happening today with technologies like AJAX being
touted as the centerpiece of some "Web Two Point Oh" sites.  I'm excited to see
where this will all go, and more than excited that, being a developer during
this time, get to help shape that direction.</p>

<p>.. <em>CouchDB: http://incubator.apache.org/couchdb/
.. </em><code>truly peer-to-peer web applications</code>: http://jchris.mfdz.com/code/2008/11/my_couch_or_yours<em><em>shareable_ap
.. </em><code>Google Gears</code>: http://gears.google.com/
.. </em>Atom: http://en.wikipedia.org/wiki/Atom<em>(standard)
.. </em>eyespot: http://eyespot.com/
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FriendFeed Comment Expand Bookmarklet]]></title>
    <link href="http://ericflo.github.com/blog/2008/05/27/friendfeed-comment-expand-bookmarklet/"/>
    <updated>2008-05-27T00:47:57-07:00</updated>
    <id>http://ericflo.github.com/blog/2008/05/27/friendfeed-comment-expand-bookmarklet</id>
    <content type="html"><![CDATA[<p>
Recently I've been using a lot of FriendFeed_ lately, and found it a bit annoying to expand comments one-by-one, so I wrote a quick bookmarklet to automatically expand all comments out.</p>

<p>Drag this bookmarklet to your bookmarks toolbar to get in on the action:</p>

<p><code>Show All Comments</code>_</p>

<p>By the way, feel free to <code>follow me</code>_ on FriendFeed as well to see my various online activities.  I'm in the habit of following people who follow me.</p>

<p>.. <em>FriendFeed: http://friendfeed.com/
.. </em><code>Show All Comments</code>: javascript: (function(A){A.parents(".commentexpander").hide();A.parents(".comments").show().find(".hiddencomments").show(100)})(jQuery('.l_showcomments'))
.. _<code>follow me</code>: http://friendfeed.com/ericflo
</p>
]]></content>
  </entry>
  
</feed>
